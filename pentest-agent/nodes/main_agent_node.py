# -*- coding: utf-8 -*-
"""
Main Agent Node
主代理节点 - Shadow Commander
"""

from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langgraph.prebuilt import create_react_agent

from core.state import PentestState
from core.config_loader import load_prompt
from agents.base_agent import create_model, clean_messages
from tools import MAIN_AGENT_TOOLS
from tools.local_tools import MAIN_AGENT_LOCAL_TOOLS


# 创建主代理
def _create_main_agent():
    """创建主代理 ReAct Agent"""
    system_prompt = load_prompt("main_agent")
    model = create_model()
    tools = MAIN_AGENT_TOOLS + MAIN_AGENT_LOCAL_TOOLS
    
    return create_react_agent(
        model=model,
        tools=tools,
        prompt=system_prompt
    )


_main_agent = None

def get_main_agent():
    """获取主代理单例"""
    global _main_agent
    if _main_agent is None:
        _main_agent = _create_main_agent()
    return _main_agent


def main_agent_node(state: PentestState) -> dict:
    """
    主代理节点
    
    职责：
    1. 分析当前状态
    2. 决定下一步行动（委派哪个子代理）
    3. 更新任务账本
    
    Args:
        state: 当前状态
        
    Returns:
        状态更新
    """
    agent = get_main_agent()
    
    # 构造上下文消息
    context = _build_context_message(state)
    
    # 准备输入并清理消息
    input_messages = list(state.get("messages", []))
    if context:
        input_messages = [HumanMessage(content=context)] + input_messages
    
    # 清理消息，避免 API 错误
    input_messages = clean_messages(input_messages)
    
    # 调用主代理
    result = agent.invoke({"messages": input_messages})
    
    # 解析主代理的决策
    next_agent = _parse_decision(result, state)
    
    # 返回状态更新
    return {
        "messages": result["messages"],
        "next_agent": next_agent
    }


def _build_context_message(state: PentestState) -> str:
    """构建上下文信息"""
    parts = []
    
    # 基本信息
    parts.append(f"## 当前状态")
    parts.append(f"- 任务戳: {state.get('stamp', '未生成')}")
    parts.append(f"- 目标: {state.get('target', '未指定')}")
    parts.append(f"- 阶段: {state.get('current_phase', 'init')}")
    
    # 侦察结果
    if state.get("recon_results"):
        parts.append(f"\n## 侦察结果")
        parts.append(f"```json\n{state['recon_results']}\n```")
    
    # 已发现的漏洞
    if state.get("findings"):
        parts.append(f"\n## 已发现漏洞: {len(state['findings'])} 个")
        for f in state["findings"]:
            parts.append(f"- [{f['severity']}] {f['vuln_type']}: {f['description'][:50]}...")
    
    # 任务历史
    if state.get("task_history"):
        parts.append(f"\n## 最近任务")
        for t in state["task_history"][-3:]:
            parts.append(f"- {t['task_id']}: {t['status']}")
    
    parts.append("\n## 请决定下一步行动")
    parts.append("在回复末尾，用 [NEXT: xxx] 格式指定下一个委派的代理：")
    parts.append("- [NEXT: recon] - 委派侦察专家")
    parts.append("- [NEXT: input_vuln] - 委派输入漏洞专家")
    parts.append("- [NEXT: access_logic] - 委派访问控制专家")
    parts.append("- [NEXT: knowledge] - 咨询知识库专家")
    parts.append("- [NEXT: report] - 生成最终报告")
    parts.append("- [NEXT: end] - 结束任务")
    
    return "\n".join(parts)


def _parse_decision(result: dict, state: PentestState) -> str:
    """
    解析主代理的决策
    
    从回复中提取 [NEXT: xxx] 标记
    """
    messages = result.get("messages", [])
    
    # 检查是否已经发现 flag
    for msg in messages:
        if isinstance(msg, AIMessage):
            content = msg.content if isinstance(msg.content, str) else str(msg.content)
            # 检测 flag 模式
            import re
            flag_patterns = [
                r'flag\{[^}]+\}',
                r'FLAG\{[^}]+\}',
                r'ctf\{[^}]+\}',
                r'CTF\{[^}]+\}',
            ]
            for pattern in flag_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    # 发现 flag，强制生成报告
                    return "report"
    
    # 从最后一条 AI 消息中提取决策
    for msg in reversed(messages):
        if isinstance(msg, AIMessage):
            content = msg.content if isinstance(msg.content, str) else str(msg.content)
            
            # 查找 [NEXT: xxx] 模式
            import re
            match = re.search(r'\[NEXT:\s*(\w+)\]', content, re.IGNORECASE)
            if match:
                decision = match.group(1).lower()
                valid_decisions = ["recon", "input_vuln", "access_logic", "knowledge", "report", "end"]
                if decision in valid_decisions:
                    return decision
            break
    
    # 默认逻辑：根据当前阶段决定
    phase = state.get("current_phase", "init")
    
    if phase == "init":
        return "recon"
    elif phase == "recon":
        return "input_vuln"
    elif phase == "vuln_test":
        return "access_logic"
    elif phase == "access_test":
        return "report"
    else:
        return "end"
