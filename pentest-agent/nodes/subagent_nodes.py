# -*- coding: utf-8 -*-
"""
Subagent Nodes
子代理节点
"""

import re
from langchain_core.messages import HumanMessage, AIMessage, ToolMessage
from langgraph.prebuilt import create_react_agent

from core.state import PentestState
from core.config_loader import load_prompt
from agents.base_agent import create_model, clean_messages
from tools import SUBAGENT_TOOLS, RECON_TOOLS
from tools.local_tools import read_local_file
from tools.mission_control import end_mission, MISSION_CONTROL_TOOLS


# ============================================================
# 子代理创建
# ============================================================

_agents_cache = {}

def _get_or_create_agent(agent_name: str, tools: list):
    """获取或创建子代理"""
    cache_key = f"{agent_name}_{len(tools)}"
    if cache_key not in _agents_cache:
        system_prompt = load_prompt(agent_name)
        model = create_model()
        _agents_cache[cache_key] = create_react_agent(
            model=model,
            tools=tools,
            prompt=system_prompt
        )
    return _agents_cache[cache_key]


def _check_end_mission(messages: list) -> tuple[bool, str]:
    """
    检查消息中是否有 end_mission 工具调用
    
    Returns:
        (mission_complete, reason)
    """
    for msg in messages:
        # 检查 ToolMessage
        if isinstance(msg, ToolMessage):
            if hasattr(msg, 'name') and msg.name == 'end_mission':
                # 从 content 中提取 reason
                content = msg.content if isinstance(msg.content, str) else str(msg.content)
                # 格式: "任务结束请求已提交。原因: xxx"
                if "原因:" in content:
                    reason = content.split("原因:")[-1].strip()
                    return True, reason
                return True, "子代理请求结束任务"
        
        # 检查 AIMessage 的 tool_calls
        if isinstance(msg, AIMessage):
            if hasattr(msg, 'tool_calls') and msg.tool_calls:
                for tc in msg.tool_calls:
                    tool_name = tc.get('name') if isinstance(tc, dict) else getattr(tc, 'name', None)
                    if tool_name == 'end_mission':
                        args = tc.get('args', {}) if isinstance(tc, dict) else getattr(tc, 'args', {})
                        reason = args.get('reason', '子代理请求结束任务')
                        return True, reason
    
    return False, ""


def _invoke_subagent(agent_name: str, tools: list, state: PentestState, task_prompt: str) -> dict:
    """
    调用子代理的通用逻辑
    
    Args:
        agent_name: 代理名称
        tools: 工具列表
        state: 当前状态
        task_prompt: 任务提示
        
    Returns:
        状态更新
    """
    # 添加 end_mission 工具到工具列表
    all_tools = tools + MISSION_CONTROL_TOOLS
    
    agent = _get_or_create_agent(agent_name, all_tools)
    
    # 构造任务消息
    task_message = HumanMessage(content=f"""
## 任务指令

任务戳: {state.get('stamp', '未知')}
目标: {state.get('target', '未知')}

{task_prompt}

## ⚠️ 重要提示

1. 如果你认为任务已完成（找到 flag、获取敏感数据、验证漏洞成功等），请调用 `end_mission(reason)` 工具结束任务。

2. 如果任务未完成，正常汇报你的发现，指挥官会决定下一步。

请执行任务。
""")
    
    # 清理消息
    messages = clean_messages([task_message])
    
    # 调用代理
    result = agent.invoke({"messages": messages})
    
    # 检查是否调用了 end_mission
    mission_complete, reason = _check_end_mission(result.get("messages", []))
    
    # 构建状态更新
    update = {
        "messages": clean_messages(result["messages"])
    }
    
    if mission_complete:
        update["mission_complete"] = True
        update["mission_end_reason"] = reason
    
    return update


# ============================================================
# 侦察专家节点
# ============================================================

def recon_agent_node(state: PentestState) -> dict:
    """
    侦察专家节点
    
    职责：
    - 端口扫描
    - 服务识别
    - 目录枚举
    - 信息收集
    """
    task_prompt = """
### 侦察任务

请执行以下侦察工作：

1. **端口扫描**: 扫描目标的常用端口 (21,22,23,25,53,80,110,143,443,445,993,995,1433,3306,3389,5432,6379,8080,8443)

2. **服务识别**: 对开放端口进行 Banner 抓取，识别服务版本

3. **目录枚举**: 如果有 Web 服务，枚举常见目录 (admin, login, api, backup, config, test, uploads, .git, robots.txt)

请使用预装工具（优先）或 deploy_and_run_task 部署扫描脚本。

完成后，总结发现的信息。如果在侦察过程中直接发现了 flag 或关键漏洞，调用 end_mission 结束任务。
"""
    
    result = _invoke_subagent("reconnaissance_agent", RECON_TOOLS, state, task_prompt)
    
    # 更新阶段
    result["current_phase"] = "recon"
    
    return result


# ============================================================
# 输入漏洞专家节点
# ============================================================

def input_vuln_agent_node(state: PentestState) -> dict:
    """
    输入漏洞专家节点
    
    职责：
    - SQL 注入测试
    - XSS 测试
    - 命令注入测试
    - 文件包含测试
    """
    # 根据侦察结果定制任务
    recon = state.get("recon_results", {})
    
    task_prompt = f"""
### 输入漏洞测试任务

侦察结果摘要：
{recon}

请针对发现的 Web 接口进行以下测试：

1. **SQL 注入**: 测试所有输入参数
2. **XSS**: 测试反射型和存储型 XSS
3. **命令注入**: 如果有疑似命令执行的接口
4. **文件包含**: 测试 LFI/RFI

对于每个发现的漏洞，使用 add_finding 记录。

如果成功利用漏洞获取了 flag 或敏感数据，调用 end_mission 结束任务。
"""
    
    result = _invoke_subagent("input_vuln_expert", SUBAGENT_TOOLS, state, task_prompt)
    result["current_phase"] = "vuln_test"
    
    return result


# ============================================================
# 访问控制专家节点
# ============================================================

def access_logic_agent_node(state: PentestState) -> dict:
    """
    访问控制专家节点
    
    职责：
    - IDOR 测试
    - 越权测试
    - 认证绕过测试
    - 业务逻辑漏洞
    """
    recon = state.get("recon_results", {})
    
    task_prompt = f"""
### 访问控制测试任务

侦察结果摘要：
{recon}

请进行以下测试：

1. **IDOR**: 测试资源 ID 是否可被篡改访问
2. **垂直越权**: 测试普通用户能否访问管理接口
3. **水平越权**: 测试能否访问其他用户资源
4. **认证绕过**: 测试认证机制是否可被绕过

对于每个发现的漏洞，使用 add_finding 记录。

如果成功获取了未授权访问或敏感数据，调用 end_mission 结束任务。
"""
    
    result = _invoke_subagent("access_logic_expert", SUBAGENT_TOOLS, state, task_prompt)
    result["current_phase"] = "access_test"
    
    return result


# ============================================================
# 知识库专家节点
# ============================================================

def knowledge_agent_node(state: PentestState) -> dict:
    """
    知识库专家节点
    
    职责：
    - CVE 漏洞查询
    - 漏洞利用搜索
    - 本地知识库检索
    """
    from tools.knowledge_tools import KNOWLEDGE_TOOLS
    
    recon = state.get("recon_results", {})
    findings = state.get("findings", [])
    
    task_prompt = f"""
### 知识库查询任务

侦察结果：
{recon}

已发现漏洞：
{findings}

请使用知识库工具查询：

1. 使用 `query_cve` 查询特定 CVE 详情
2. 使用 `search_vulnerabilities` 搜索服务相关漏洞
3. 使用 `search_exploits` 搜索可用的利用代码
4. 使用 `search_knowledge_base` 检索本地文档

请提供：已知漏洞列表、利用建议、下一步测试方向
"""
    
    # 知识库专家使用知识库工具
    tools = SUBAGENT_TOOLS + KNOWLEDGE_TOOLS
    
    result = _invoke_subagent("knowledge_agent", tools, state, task_prompt)
    
    return result


# ============================================================
# 报告生成节点
# ============================================================

def report_node(state: PentestState) -> dict:
    """
    报告生成节点
    
    生成最终的渗透测试报告
    """
    from tools.local_tools import update_mission_log
    
    # 获取结束原因
    end_reason = state.get("mission_end_reason", "任务正常完成")
    
    # 构建报告内容
    report = f"""# 渗透测试报告

## 基本信息
- 任务戳: {state.get('stamp', 'N/A')}
- 目标: {state.get('target', 'N/A')}
- 任务名称: {state.get('mission_name', 'N/A')}
- 结束原因: {end_reason}

## 侦察结果
{state.get('recon_results', '无')}

## 漏洞发现 ({len(state.get('findings', []))} 个)
"""
    
    for i, f in enumerate(state.get("findings", []), 1):
        report += f"""
### {i}. [{f.get('severity', 'N/A').upper()}] {f.get('vuln_type', 'N/A')}
- 描述: {f.get('description', 'N/A')}
- 证据: {f.get('evidence', {})}
"""
    
    report += f"""
## 任务日志
"""
    for t in state.get("task_history", []):
        report += f"- {t.get('task_id', 'N/A')}: {t.get('status', 'N/A')}\n"
    
    report += "\n## 状态: 已完成"
    
    # 保存报告
    update_mission_log.invoke({"content": report, "append": False})
    
    return {
        "current_phase": "completed",
        "messages": [AIMessage(content=f"报告已生成并保存到任务账本。\n\n{report}")]
    }
