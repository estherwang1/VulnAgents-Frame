# -*- coding: utf-8 -*-
"""
Subagent Nodes
子代理节点
"""

from langchain_core.messages import HumanMessage, AIMessage
from langgraph.prebuilt import create_react_agent

from core.state import PentestState
from core.config_loader import load_prompt
from agents.base_agent import create_model, clean_messages
from tools import SUBAGENT_TOOLS, RECON_TOOLS
from tools.local_tools import read_local_file


# ============================================================
# 子代理创建
# ============================================================

_agents_cache = {}

def _get_or_create_agent(agent_name: str, tools: list):
    """获取或创建子代理"""
    if agent_name not in _agents_cache:
        system_prompt = load_prompt(agent_name)
        model = create_model()
        _agents_cache[agent_name] = create_react_agent(
            model=model,
            tools=tools,
            prompt=system_prompt
        )
    return _agents_cache[agent_name]


def _invoke_subagent(agent_name: str, tools: list, state: PentestState, task_prompt: str) -> dict:
    """
    调用子代理的通用逻辑
    
    Args:
        agent_name: 代理名称
        tools: 工具列表
        state: 当前状态
        task_prompt: 任务提示
        
    Returns:
        状态更新
    """
    import re
    
    agent = _get_or_create_agent(agent_name, tools)
    
    # 构造任务消息
    task_message = HumanMessage(content=f"""
## 任务指令

任务戳: {state.get('stamp', '未知')}
目标: {state.get('target', '未知')}

{task_prompt}

⚠️ 重要：如果发现 flag（如 flag{{...}}），立即停止并汇报！

请执行任务，完成后汇报结果。
""")
    
    # 清理消息
    messages = clean_messages([task_message])
    
    # 调用代理
    result = agent.invoke({"messages": messages})
    
    # 检查是否发现 flag
    found_flag = None
    for msg in result.get("messages", []):
        if isinstance(msg, AIMessage):
            content = msg.content if isinstance(msg.content, str) else str(msg.content)
            flag_match = re.search(r'flag\{[^}]+\}', content, re.IGNORECASE)
            if flag_match:
                found_flag = flag_match.group()
                break
    
    # 如果发现 flag，添加到 findings
    update = {
        "messages": clean_messages(result["messages"])
    }
    
    if found_flag:
        current_findings = state.get("findings", [])
        update["findings"] = current_findings + [{
            "vuln_type": "flag_captured",
            "severity": "critical",
            "description": f"成功获取 Flag: {found_flag}",
            "evidence": {"flag": found_flag}
        }]
    
    return update


# ============================================================
# 侦察专家节点
# ============================================================

def recon_agent_node(state: PentestState) -> dict:
    """
    侦察专家节点
    
    职责：
    - 端口扫描
    - 服务识别
    - 目录枚举
    - 信息收集
    """
    task_prompt = """
### 侦察任务

请执行以下侦察工作：

1. **端口扫描**: 扫描目标的常用端口 (21,22,23,25,53,80,110,143,443,445,993,995,1433,3306,3389,5432,6379,8080,8443)

2. **服务识别**: 对开放端口进行 Banner 抓取，识别服务版本

3. **目录枚举**: 如果有 Web 服务，枚举常见目录 (admin, login, api, backup, config, test, uploads, .git, robots.txt)

请使用 deploy_and_run_task 部署扫描脚本并执行，然后用 get_task_result 获取结果。

完成后，总结发现的信息。
"""
    
    result = _invoke_subagent("reconnaissance_agent", RECON_TOOLS, state, task_prompt)
    
    # 更新阶段
    result["current_phase"] = "recon"
    
    # TODO: 解析侦察结果到 recon_results
    
    return result


# ============================================================
# 输入漏洞专家节点
# ============================================================

def input_vuln_agent_node(state: PentestState) -> dict:
    """
    输入漏洞专家节点
    
    职责：
    - SQL 注入测试
    - XSS 测试
    - 命令注入测试
    - 文件包含测试
    """
    # 根据侦察结果定制任务
    recon = state.get("recon_results", {})
    
    task_prompt = f"""
### 输入漏洞测试任务

侦察结果摘要：
{recon}

请针对发现的 Web 接口进行以下测试：

1. **SQL 注入**: 测试所有输入参数
2. **XSS**: 测试反射型和存储型 XSS
3. **命令注入**: 如果有疑似命令执行的接口
4. **文件包含**: 测试 LFI/RFI

对于每个发现的漏洞，使用 add_finding 记录。

请使用 deploy_and_run_task 部署测试脚本。
"""
    
    result = _invoke_subagent("input_vuln_expert", SUBAGENT_TOOLS, state, task_prompt)
    result["current_phase"] = "vuln_test"
    
    return result


# ============================================================
# 访问控制专家节点
# ============================================================

def access_logic_agent_node(state: PentestState) -> dict:
    """
    访问控制专家节点
    
    职责：
    - IDOR 测试
    - 越权测试
    - 认证绕过测试
    - 业务逻辑漏洞
    """
    recon = state.get("recon_results", {})
    
    task_prompt = f"""
### 访问控制测试任务

侦察结果摘要：
{recon}

请进行以下测试：

1. **IDOR**: 测试资源 ID 是否可被篡改访问
2. **垂直越权**: 测试普通用户能否访问管理接口
3. **水平越权**: 测试能否访问其他用户资源
4. **认证绕过**: 测试认证机制是否可被绕过

对于每个发现的漏洞，使用 add_finding 记录。
"""
    
    result = _invoke_subagent("access_logic_expert", SUBAGENT_TOOLS, state, task_prompt)
    result["current_phase"] = "access_test"
    
    return result


# ============================================================
# 知识库专家节点
# ============================================================

def knowledge_agent_node(state: PentestState) -> dict:
    """
    知识库专家节点
    
    职责：
    - CVE 漏洞查询
    - 漏洞利用搜索
    - 本地知识库检索
    """
    from tools.knowledge_tools import KNOWLEDGE_TOOLS
    
    recon = state.get("recon_results", {})
    findings = state.get("findings", [])
    
    task_prompt = f"""
### 知识库查询任务

侦察结果：
{recon}

已发现漏洞：
{findings}

请使用知识库工具查询：

1. 使用 `query_cve` 查询特定 CVE 详情
2. 使用 `search_vulnerabilities` 搜索服务相关漏洞
3. 使用 `search_exploits` 搜索可用的利用代码
4. 使用 `search_knowledge_base` 检索本地文档

请提供：已知漏洞列表、利用建议、下一步测试方向
"""
    
    # 知识库专家使用知识库工具
    tools = SUBAGENT_TOOLS + KNOWLEDGE_TOOLS
    
    result = _invoke_subagent("knowledge_agent", tools, state, task_prompt)
    
    return result


# ============================================================
# 报告生成节点
# ============================================================

def report_node(state: PentestState) -> dict:
    """
    报告生成节点
    
    生成最终的渗透测试报告
    """
    from tools.local_tools import update_mission_log
    
    # 构建报告内容
    report = f"""# 渗透测试报告

## 基本信息
- 任务戳: {state.get('stamp', 'N/A')}
- 目标: {state.get('target', 'N/A')}
- 任务名称: {state.get('mission_name', 'N/A')}

## 侦察结果
{state.get('recon_results', '无')}

## 漏洞发现 ({len(state.get('findings', []))} 个)
"""
    
    for i, f in enumerate(state.get("findings", []), 1):
        report += f"""
### {i}. [{f.get('severity', 'N/A').upper()}] {f.get('vuln_type', 'N/A')}
- 描述: {f.get('description', 'N/A')}
- 证据: {f.get('evidence', {})}
"""
    
    report += f"""
## 任务日志
"""
    for t in state.get("task_history", []):
        report += f"- {t.get('task_id', 'N/A')}: {t.get('status', 'N/A')}\n"
    
    report += "\n## 状态: 已完成"
    
    # 保存报告
    update_mission_log.invoke({"content": report, "append": False})
    
    return {
        "current_phase": "completed",
        "messages": [AIMessage(content=f"报告已生成并保存到任务账本。\n\n{report}")]
    }
