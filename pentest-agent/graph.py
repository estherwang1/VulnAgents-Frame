# -*- coding: utf-8 -*-
"""
Pentest Graph
渗透测试状态图 - 主入口
"""

import os
from dotenv import load_dotenv

load_dotenv()

from typing import Literal
from langgraph.graph import StateGraph, END
from langchain_core.messages import HumanMessage

from core.state import PentestState
from core.config_loader import config_loader


# 判断是否启用知识库
def is_knowledge_enabled() -> bool:
    """检查是否启用知识库"""
    mode = os.getenv("MODE", "ctf").lower()
    if mode == "ctf":
        return False
    knowledge_config = config_loader.system.get("knowledge", {})
    return str(knowledge_config.get("enabled", "false")).lower() == "true"


KNOWLEDGE_ENABLED = is_knowledge_enabled()


def parse_target_from_messages(state: PentestState) -> PentestState:
    """
    从用户消息中解析目标
    """
    messages = state.get("messages", [])
    target = state.get("target", "")
    mission_name = state.get("mission_name", "渗透测试任务")
    
    if not target and messages:
        for msg in reversed(messages):
            if isinstance(msg, HumanMessage) or (hasattr(msg, 'type') and msg.type == 'human'):
                content = msg.content if hasattr(msg, 'content') else str(msg)
                
                if isinstance(content, list):
                    text_parts = []
                    for part in content:
                        if isinstance(part, str):
                            text_parts.append(part)
                        elif isinstance(part, dict) and 'text' in part:
                            text_parts.append(part['text'])
                    content = ' '.join(text_parts)
                
                target = content.strip() if isinstance(content, str) else str(content).strip()
                break
    
    return {
        "target": target,
        "mission_name": mission_name
    }


def should_continue_after_init(state: PentestState) -> Literal["main_agent", "end"]:
    """初始化后的路由"""
    if state.get("error"):
        return "end"
    return "main_agent"


def route_from_main_agent(state: PentestState) -> str:
    """
    主代理决策路由
    
    优先检查 mission_complete 标志
    """
    # 1. 首先检查 mission_complete 标志（子代理通过 end_mission 设置）
    if state.get("mission_complete"):
        return "report"
    
    # 2. 获取 main_agent 的决策
    next_agent = state.get("next_agent", "end")
    
    # CTF 模式不支持 knowledge
    if KNOWLEDGE_ENABLED:
        valid_routes = ["recon", "input_vuln", "access_logic", "knowledge", "report", "end"]
    else:
        valid_routes = ["recon", "input_vuln", "access_logic", "report", "end"]
        # 如果主代理尝试调用 knowledge，直接跳到下一个合理步骤
        if next_agent == "knowledge":
            return "input_vuln"
    
    if next_agent not in valid_routes:
        return "end"
    
    return next_agent


def route_after_subagent(state: PentestState) -> str:
    """
    子代理完成后的路由
    
    检查 mission_complete，决定是回 main_agent 还是直接 report
    """
    if state.get("mission_complete"):
        return "report"
    return "main_agent"


def build_graph() -> StateGraph:
    """
    构建渗透测试状态图
    
    根据配置决定是否包含知识库节点
    """
    from nodes import (
        init_node,
        main_agent_node,
        recon_agent_node,
        input_vuln_agent_node,
        access_logic_agent_node,
        report_node,
    )
    
    workflow = StateGraph(PentestState)
    
    # ============================================================
    # 添加节点
    # ============================================================
    
    workflow.add_node("parse_input", parse_target_from_messages)
    workflow.add_node("init", init_node)
    workflow.add_node("main_agent", main_agent_node)
    workflow.add_node("recon", recon_agent_node)
    workflow.add_node("input_vuln", input_vuln_agent_node)
    workflow.add_node("access_logic", access_logic_agent_node)
    workflow.add_node("report", report_node)
    
    # 根据配置添加知识库节点
    if KNOWLEDGE_ENABLED:
        from nodes import knowledge_agent_node
        workflow.add_node("knowledge", knowledge_agent_node)
    
    # ============================================================
    # 设置入口
    # ============================================================
    
    workflow.set_entry_point("parse_input")
    
    # ============================================================
    # 添加边
    # ============================================================
    
    workflow.add_edge("parse_input", "init")
    
    workflow.add_conditional_edges(
        "init",
        should_continue_after_init,
        {
            "main_agent": "main_agent",
            "end": END
        }
    )
    
    # 根据模式构建路由表
    if KNOWLEDGE_ENABLED:
        route_map = {
            "recon": "recon",
            "input_vuln": "input_vuln",
            "access_logic": "access_logic",
            "knowledge": "knowledge",
            "report": "report",
            "end": END
        }
    else:
        route_map = {
            "recon": "recon",
            "input_vuln": "input_vuln",
            "access_logic": "access_logic",
            "report": "report",
            "end": END
        }
    
    workflow.add_conditional_edges(
        "main_agent",
        route_from_main_agent,
        route_map
    )
    
    # 子代理完成后：检查 mission_complete，决定去 main_agent 还是 report
    subagent_route_map = {
        "main_agent": "main_agent",
        "report": "report"
    }
    
    workflow.add_conditional_edges("recon", route_after_subagent, subagent_route_map)
    workflow.add_conditional_edges("input_vuln", route_after_subagent, subagent_route_map)
    workflow.add_conditional_edges("access_logic", route_after_subagent, subagent_route_map)
    
    if KNOWLEDGE_ENABLED:
        workflow.add_conditional_edges("knowledge", route_after_subagent, subagent_route_map)
    
    workflow.add_edge("report", END)
    
    return workflow


def create_graph():
    """创建并编译图"""
    workflow = build_graph()
    return workflow.compile()


# 打印当前模式
_mode = os.getenv("MODE", "ctf")
print(f"[PentestAgent] 模式: {_mode.upper()}, 知识库: {'启用' if KNOWLEDGE_ENABLED else '禁用'}")

# 导出编译后的图
graph = create_graph()


# ============================================================
# 便捷运行函数
# ============================================================

def run_pentest(target: str, mission_name: str = "渗透测试任务"):
    """运行渗透测试"""
    from core.state import create_initial_state
    
    initial_state = create_initial_state(target, mission_name)
    # 设置递归限制，防止 "need more steps" 错误
    final_state = graph.invoke(initial_state, {"recursion_limit": 100})
    
    return final_state


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("用法: python graph.py <目标地址>")
        sys.exit(1)
    
    target = sys.argv[1]
    print(f"开始渗透测试: {target}")
    
    result = run_pentest(target)
    
    print("\n" + "=" * 60)
    print("任务完成")
    print("=" * 60)
    print(f"任务戳: {result.get('stamp')}")
    print(f"发现漏洞: {len(result.get('findings', []))} 个")
