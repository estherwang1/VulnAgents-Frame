# -*- coding: utf-8 -*-
"""
Knowledge Base
知识库抽象层 - 支持多种数据源
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from dataclasses import dataclass


@dataclass
class KnowledgeResult:
    """知识查询结果"""
    source: str           # 来源：nvd, exploitdb, rag, llm
    query: str            # 查询内容
    results: List[Dict]   # 结果列表
    confidence: float     # 置信度 0-1
    raw_response: Any     # 原始响应


class KnowledgeSource(ABC):
    """知识源抽象基类"""
    
    @property
    @abstractmethod
    def name(self) -> str:
        """数据源名称"""
        pass
    
    @property
    @abstractmethod
    def enabled(self) -> bool:
        """是否启用"""
        pass
    
    @abstractmethod
    async def query(self, query: str, **kwargs) -> KnowledgeResult:
        """
        查询知识
        
        Args:
            query: 查询内容
            **kwargs: 额外参数
            
        Returns:
            KnowledgeResult
        """
        pass
    
    @abstractmethod
    async def health_check(self) -> bool:
        """健康检查"""
        pass


class KnowledgeManager:
    """
    知识库管理器
    
    统一管理多个知识源，按优先级查询
    """
    
    def __init__(self):
        self._sources: List[KnowledgeSource] = []
    
    def register(self, source: KnowledgeSource, priority: int = 0):
        """
        注册知识源
        
        Args:
            source: 知识源实例
            priority: 优先级，数字越小优先级越高
        """
        self._sources.append((priority, source))
        self._sources.sort(key=lambda x: x[0])
    
    def get_enabled_sources(self) -> List[KnowledgeSource]:
        """获取所有启用的知识源"""
        return [s for _, s in self._sources if s.enabled]
    
    async def query(self, query: str, sources: Optional[List[str]] = None, **kwargs) -> List[KnowledgeResult]:
        """
        查询知识
        
        Args:
            query: 查询内容
            sources: 指定查询的数据源名称列表，None 表示全部
            **kwargs: 额外参数
            
        Returns:
            所有数据源的查询结果
        """
        results = []
        
        for _, source in self._sources:
            if not source.enabled:
                continue
            if sources and source.name not in sources:
                continue
            
            try:
                result = await source.query(query, **kwargs)
                results.append(result)
            except Exception as e:
                # 记录错误但继续查询其他源
                results.append(KnowledgeResult(
                    source=source.name,
                    query=query,
                    results=[],
                    confidence=0,
                    raw_response={"error": str(e)}
                ))
        
        return results
    
    async def query_first(self, query: str, **kwargs) -> Optional[KnowledgeResult]:
        """查询并返回第一个有结果的"""
        results = await self.query(query, **kwargs)
        for r in results:
            if r.results:
                return r
        return None


# 全局知识库管理器
knowledge_manager = KnowledgeManager()
