# -*- coding: utf-8 -*-
"""
Base Agent 工具函数
"""

import os
from typing import List, Set
from langchain_core.messages import AIMessage, HumanMessage, ToolMessage
from langgraph.prebuilt import create_react_agent

from core.config_loader import load_prompt


def clean_messages(messages: List) -> List:
    """
    清理消息列表，修复可能导致 API 错误的问题：
    - 移除 assistant 消息末尾的空白字符
    - 确保消息内容不为空
    - 确保每个 tool_use 都有对应的 tool_result
    """
    if not messages:
        return []
    
    cleaned = []
    
    # 第一遍：收集所有 tool_call_id 和 tool_result_id
    tool_use_ids: Set[str] = set()
    tool_result_ids: Set[str] = set()
    
    for msg in messages:
        # 收集 tool_use ids
        if isinstance(msg, AIMessage):
            if hasattr(msg, 'tool_calls') and msg.tool_calls:
                for tc in msg.tool_calls:
                    if isinstance(tc, dict) and 'id' in tc:
                        tool_use_ids.add(tc['id'])
                    elif hasattr(tc, 'id'):
                        tool_use_ids.add(tc.id)
            # 也检查 content 中的 tool_use
            if isinstance(msg.content, list):
                for part in msg.content:
                    if isinstance(part, dict) and part.get('type') == 'tool_use':
                        if 'id' in part:
                            tool_use_ids.add(part['id'])
        
        # 收集 tool_result ids
        if isinstance(msg, ToolMessage):
            if hasattr(msg, 'tool_call_id') and msg.tool_call_id:
                tool_result_ids.add(msg.tool_call_id)
    
    # 找出没有对应 result 的 tool_use ids
    orphan_tool_ids = tool_use_ids - tool_result_ids
    
    # 第二遍：清理消息
    for msg in messages:
        if isinstance(msg, AIMessage):
            content = msg.content
            
            # 如果有 tool_calls，检查是否有 orphan
            has_orphan = False
            if hasattr(msg, 'tool_calls') and msg.tool_calls:
                for tc in msg.tool_calls:
                    tc_id = tc.get('id') if isinstance(tc, dict) else getattr(tc, 'id', None)
                    if tc_id in orphan_tool_ids:
                        has_orphan = True
                        break
            
            # 检查 content 中的 tool_use
            if isinstance(content, list):
                for part in content:
                    if isinstance(part, dict) and part.get('type') == 'tool_use':
                        if part.get('id') in orphan_tool_ids:
                            has_orphan = True
                            break
            
            # 如果有 orphan tool_use，跳过这条消息
            if has_orphan:
                continue
            
            # 清理内容
            if isinstance(content, str):
                content = content.rstrip()
                if content:
                    cleaned.append(AIMessage(content=content))
            elif isinstance(content, list):
                new_content = []
                for part in content:
                    if isinstance(part, str):
                        part = part.rstrip()
                        if part:
                            new_content.append(part)
                    elif isinstance(part, dict):
                        # 跳过 orphan tool_use
                        if part.get('type') == 'tool_use' and part.get('id') in orphan_tool_ids:
                            continue
                        new_content.append(part)
                    else:
                        new_content.append(part)
                if new_content:
                    # 保留原始的 tool_calls（如果有且不是 orphan）
                    new_msg = AIMessage(content=new_content)
                    if hasattr(msg, 'tool_calls') and msg.tool_calls:
                        valid_tool_calls = []
                        for tc in msg.tool_calls:
                            tc_id = tc.get('id') if isinstance(tc, dict) else getattr(tc, 'id', None)
                            if tc_id not in orphan_tool_ids:
                                valid_tool_calls.append(tc)
                        if valid_tool_calls:
                            new_msg.tool_calls = valid_tool_calls
                    cleaned.append(new_msg)
            else:
                cleaned.append(msg)
        
        elif isinstance(msg, ToolMessage):
            # 只保留有对应 tool_use 的 tool_result
            if hasattr(msg, 'tool_call_id') and msg.tool_call_id:
                if msg.tool_call_id in tool_use_ids:
                    cleaned.append(msg)
            else:
                cleaned.append(msg)
        
        elif isinstance(msg, HumanMessage):
            content = msg.content
            if isinstance(content, str):
                if content.strip():
                    cleaned.append(msg)
            elif isinstance(content, list):
                if content:
                    cleaned.append(msg)
            else:
                cleaned.append(msg)
        
        else:
            cleaned.append(msg)
    
    return cleaned


def create_model():
    """
    创建 LLM 模型实例
    
    从 .env 环境变量读取配置：
    - ANTHROPIC_MODEL: 模型名称
    - ANTHROPIC_BASE_URL: API 地址（可选，聚合平台用户填写）
    """
    from langchain_anthropic import ChatAnthropic
    
    kwargs = {
        "model": os.getenv("ANTHROPIC_MODEL", "claude-sonnet-4-20250514"),
        "temperature": 0,
        "max_tokens": 4096,
    }
    
    base_url = os.getenv("ANTHROPIC_BASE_URL")
    if base_url:
        kwargs["base_url"] = base_url
    
    return ChatAnthropic(**kwargs)


def create_subagent(agent_name: str, tools: list):
    """
    创建子代理
    
    Args:
        agent_name: 代理名称，用于加载对应的提示词
        tools: 代理可用的工具列表
    
    Returns:
        LangGraph Agent
    """
    system_prompt = load_prompt(agent_name)
    model = create_model()
    
    return create_react_agent(
        model=model,
        tools=tools,
        prompt=system_prompt
    )


class SubAgentFactory:
    """子代理工厂类"""
    
    _agents = {}
    
    @classmethod
    def get_or_create(cls, agent_name: str, tools: list):
        """获取或创建子代理（带缓存）"""
        if agent_name not in cls._agents:
            cls._agents[agent_name] = create_subagent(agent_name, tools)
        return cls._agents[agent_name]
    
    @classmethod
    def clear_cache(cls):
        """清除缓存"""
        cls._agents.clear()


# 全局工厂实例
agent_factory = SubAgentFactory()